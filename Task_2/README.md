# Задание 2
## Оценка вставки и обновления записи в Payment

Для того, чтобы оценить относительное время исполнения операции вставки, используется встроенный в Microsoft SQL Server Management Studio инструмент Live Query Statistics.

### Вставка

При исполнении скрипта с операцией вставки также используется операция отката, на которую уходит 2%. Поэтому операция вставки использует 98% относительного времени.

1. Вставка записи в Payment - 6%
   
2. Обновление баланса у новых участников - 36%
   
   2.1. Старт обновления баланса для плательщика - 2%

   2.2 Обновление баланса у плательщика в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 16%

   2.3. Старт обновления баланса для получателя - 2%

   2.4 Обновление баланса у получателя в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 16%

3. Обновление баланса у старых участников - 36%
   
   3.1. Старт обновления баланса для плательщика - 2%

   3.2 Обновление баланса у плательщика в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 16%

   3.3. Старт обновления баланса для получателя - 2%

   3.4 Обновление баланса у получателя в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 16%

4. Обновление баланса у новых оъектов - 10%

    4.1. Старт обновления баланса для нового объекта - 2%

    4.2 Обновление баланса в таблице Project с помощью триггера T_Project_BU - 8%

5. Обновление баланса у старых оъектов - 10%

    5.1. Старт обновления баланса для старого объекта - 2%

    5.2 Обновление баланса в таблице Project с помощью триггера T_Project_BU - 8%


### Обновление

При исполнении скрипта с операцией вставки также используется операция отката, на которую уходит 3%. Поэтому операция вставки использует 97% относительного времени.

1. Обновление записи в Payment - 1%
   
2. Обновление баланса у новых участников - 38%
   
   2.1. Старт обновления баланса для плательщика - 2%

   2.2 Обновление баланса у плательщика в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 17%

   2.3. Старт обновления баланса для получателя - 2%

   2.4 Обновление баланса у получателя в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 17%

3. Обновление баланса у старых участников - 38%
   
   3.1. Старт обновления баланса для плательщика - 2%

   3.2 Обновление баланса у плательщика в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 17%

   3.3. Старт обновления баланса для получателя - 2%

   3.4 Обновление баланса у получателя в таблице PaymentParticipant с помощью триггера T_PaymentParticipant_BU - 17%

4. Обновление баланса у новых оъектов - 10%

    4.1. Старт обновления баланса для нового объекта - 2%

    4.2 Обновление баланса в таблице Project с помощью триггера T_Project_BU - 8%

5. Обновление баланса у старых оъектов - 10%

    5.1. Старт обновления баланса для старого объекта - 2%

    5.2 Обновление баланса в таблице Project с помощью триггера T_Project_BU - 8%

## Предложить сценарий оптимизации механизмов расчёта

Для оптимизации можно создать дополнительную таблицу для Payment. 

В эту таблицу будут поподать данные, вносимые оператором. При этом при добавлении записей в эту таблицу балансы пересчитываться не будут.

Когда же анилитик будет запускать некоторые аналитические расчеты, данные из доп. таблицы будут переносится в основную, после чего будет вызываться пересчет балансов для добавленных данных.

## Оценить недостатки предлагаемого сценария

Такой подход позволит намного быстрее добавлять записи в Payment, однако снизится скорость аналитических запросов. Однако стоит заметить, что на мой взгляд, операции вставки записей в Payment оператором осуществляется намного чаще, чем запросы, выполняемые аналитиком.
